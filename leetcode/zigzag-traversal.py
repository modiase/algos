"""

Notes
=====
## Summary
T: 20
C: Y
PD: 2

## Comments

Got a bit confused about the implementation and need to make sure I am keeping
in mind how when the list is reversed it is only reversed for the result, because
of the way I'm traversing each level, if I reverse the list before traversing then
you end up putting the children in the wrong order (left child or rightmost, right
child of rightmost, left child of second right most) and not (left child of leftmost
...) which results in the correct traversal when reversed.

tags: trees, traversal, b-trees
"""

from collections import deque
from typing import List, Optional


class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

    def __str__(self):
        return str(self.val)

    def __repr__(self):
        return f"<TreeNode value={self.val} left={self.left} right={self.right}>"


# Updated solution (generated by claude)
def zigzag_traverse(root: Optional[TreeNode]) -> List[List[int]]:
    if root is None:
        return []
        
    result = []
    q = deque([root])  # Start with just the root node
    leftToRight = True  # Start with left-to-right for first level
    
    while q:
        level = []
        level_size = len(q)  # Process nodes level by level
        
        # Process all nodes at current level
        for _ in range(level_size):
            node = q.popleft()
            level.append(node.val)
            
            if node.left:
                q.append(node.left)
            if node.right:
                q.append(node.right)
        
        # Add level to result (reverse if needed)
        if not leftToRight:
            level.reverse()
        result.append(level)
        
        leftToRight = not leftToRight
    
    return result

if __name__ == "__main__":
    # Test cases
    # Empty tree
    assert zigzag_traverse(None) == []

    # Single node
    assert zigzag_traverse(TreeNode(1)) == [[1]]

    # Two elements per level
    assert zigzag_traverse(
        TreeNode(1, 
            TreeNode(2, TreeNode(4), TreeNode(5)),
            TreeNode(3, TreeNode(6), TreeNode(7)))
    ) == [[1], [3, 2], [4, 5, 6, 7]]

    # Left-skewed tree
    assert zigzag_traverse(
        TreeNode(1,
            TreeNode(2,
                TreeNode(3,
                    TreeNode(4))))
    ) == [[1], [2], [3], [4]]

    # Right-skewed tree
    assert zigzag_traverse(
        TreeNode(1,
            right=TreeNode(2,
                right=TreeNode(3,
                    right=TreeNode(4))))
    ) == [[1], [2], [3], [4]]

    # Two elements per level only
    assert zigzag_traverse(
        TreeNode(1,
            TreeNode(2),
            TreeNode(3))
    ) == [[1], [3, 2]]

    # Unbalanced tree with gaps
    assert zigzag_traverse(
        TreeNode(1,
            TreeNode(2, right=TreeNode(4)),
            TreeNode(3, left=TreeNode(5)))
    ) == [[1], [3, 2], [4, 5]]